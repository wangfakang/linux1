{"name":"Linux1","tagline":"linux process commuinte pipe signal sem shm","body":"`有关进程间通信的讲解`\r\n\r\nIPC技术：进程通信，有以下几种种：\r\n\r\n  管道：1 有名管道 2  无名管道\r\n  3 System V IPC （信号量）\r\n  4 套接字\r\n  5 消息队列\r\n  \r\n\r\n一．有关管道的讲解\r\n====\r\n  首先管道是用于两个不同进程之间的数据传递，即实现进程之间的通信，其思想就是共享某个存储区. \r\n\r\n\r\n问题一有关管道的详解：\r\n\r\n  管道是半双工通信\r\n```\r\n  int  pipe(int fd[2]);\r\n```\r\n  * fd[2]:用于返回文件描述符的数组\r\n\r\n  *  返回值：成功返回0，失败返回-1\r\n\r\n  注意：　都在内存中\r\n如：\r\n\r\n```c\r\n  int  main()\r\n{\r\n int fd[2]={0};\r\n if(pipe(fd)==-1)\r\n{\r\nreturn -1;\r\n}\r\n\r\nchar buffer[256]={0};\r\n\r\nwrite(fd[1],\"hello\",5);\r\n\r\nsleep(1);\r\n\r\nread(fd[0],buffer,255);\r\n\r\nprintf(\"buffer=\");\r\n\r\nreturn 0;\r\n}\r\n\r\n``` \r\n结果为： hello\r\n\r\n\r\n测试管道的大小：    \r\n\r\n原理是：当管道里面写满的时候就会阻塞    \r\n\r\n```c \r\n\r\n  int  main()\r\n{\r\n int fd[2]={0};\r\n\r\n if(pipe(fd)==-1)\r\n{\r\nstr\r\nsleep\r\n\r\nreturn -1;\r\n}\r\n\r\nwhile(1)\r\n{\r\nwrite(fd[1],'1',1);\r\n\r\nprintf(\"i=%d\\n\",i++);\r\n\r\n\r\n}\r\n\r\n}\r\n```\r\n\r\n结果是输出 i=65535    \r\n\r\n即是：  变化了16位，2的16次方，即64k，  每一页有4k  。    \r\n\r\n其大小可以在include/linux/limits/中的BUF_SIZE\r\n就是管道的大小      \r\n\r\n两个进程的通信例子：    \r\n\r\n在子进程中写入hello在父进程中读出来  \r\n\r\n```c\r\n int  main()\r\n{\r\n int fd[2]={0};\r\n if(pipe(fd)==-1)\r\n{\r\nreturn -1;\r\n}\r\npid_t pid=fork();\r\nassert(pid!=-1);\r\nif(0==pid)\r\n{\r\nsleep(1);\r\nwrite(fd[1],\"hello\",5);\r\nclose(fd[0]);\r\nclose(fd[1]);\r\n}\r\n\r\nelse\r\n{\r\nchar buffer[256]={0};\r\nread(fd[0],buffer,255);\r\nprintf(\"buffer=%s\",buffer);\r\nclose(fd[0]);\r\nclose(fd[1]);\r\n}\r\n\r\nreturn 0;\r\n}\r\n```\r\n问题一注意：       \r\n    两个进程之间通信的时候，对于父进程到子进程的管道，父进程应该关闭读端（fd[0],反之则相反）　　　\r\n\r\n* 1.当读一个写端已经被关闭的时候，在所有数据都读完后read返回0，指示到文件的结束\r\n\r\n* 2.当写一个读端已经被关闭的时候，则产生SIGPIPE信号，如果忽略该信号或者捕获该信号并从其处理程序返回，则write返回出错，errno设置为EPIPE\r\n\r\n\r\n```c  \r\n\r\nint main()\r\n{\r\n    int fd[2];\r\n    pipe(fd);\r\n    pid_t pid =fork();\r\n    assert(pid!=-1);\r\n    if(pid==0)\r\n{\r\n   char buffer[256]={0};\r\nchar *p=buffer;\r\nclose(fd[1]);\r\n while(read(fd[0],buffer,255)>0)\r\n{\r\n   while(*p!='\\0')\r\n{\r\nif(*p>='a'  &&  *p<='z')\r\n{\r\n*p-=32;\r\n\r\n}\r\n++p;\r\n\r\n}\r\nputs(buffer);\r\nmemset(buffer,0,256);\r\n\r\n}\r\n\r\n}\r\n\r\nelse\r\n{\r\nclose(fd[0]);\r\n\r\nint i=10;\r\nwhile(i--)\r\n{\r\nwrite(fd[1],\"hell0\",5);\r\n\r\n}\r\n\r\nclose(fd[1]);\r\n\r\n\r\n}\r\n\r\nexit(0);\r\n\r\n}\r\n```\r\n\r\n结果：   \r\n\r\n  * 1.在fork之前write  若close(fd[0])则子进程的read无法读取，直接终止程序。\r\n  * 2.在fork之前write  若没有close(fd[0])则同时输出10个\r\n  * 3.在fork之后write  若没有close(fd[0])则同时输出20个\r\n  * 4.在fork之后在父进程中write 则输出10个\r\n\r\n\r\n有名管道\r\n====\r\n\r\nmkfifow.c\r\n\r\n```c  \r\n\r\n int main()\r\n{\r\n  if(access(\"./fifo\",F_OK)!=0)\r\n { \r\n    int res=mkfifo(\"./fifo\",0666);\r\n    assert(res!=-1);\r\n }\r\n  puts(\"mkfifo  success...\");\r\n  int fdw=open(\"./fifo\",O_WRONLY);\r\n  assert(fdw!=-1);\r\n  puts(\"w open success...\");\r\n  \r\n  close(fdw);\r\n\r\n}\r\n\r\nmkfifor.c\r\n\r\n int main()\r\n{\r\n  if(access(\"./fifo\",F_OK)!=0)\r\n { \r\n    int res=mkfifo(\"./fifo\",0666);\r\n    assert(res!=-1);\r\n}\r\n  puts(\"mkfifo  success...\");\r\n  int fdw=open(\"./fifo\",O_RDONLY);\r\n  assert(fdw!=-1);\r\n  puts(\"r open success...\");\r\n  \r\n  close(fdw);\r\n\r\n}\r\n```\r\n\r\naccess(\"./fifo\",F_OK)//用于判断在当前目录中是否已经存在一个名字为fifo的文件，若有的话则返回0，\r\nmkfifo(\"./fifo\",0666);//      \r\n\r\n* 第一个参数：表示文件名和路径   \r\n\r\n* 第二个参数表示：文件的权限    \r\n\r\n## 注意：\r\n   若当该函数执行的时候，已经存在一个\"./fifo\"文件了，则会失败返回 -1；\r\n\r\n## 注意：\r\n   和操作无名管道一样，只不过是在操作无名管道的时候我们不在显示的调用Open函数打开管道文件了。     \r\n\r\n   切记：操作无名管道阻塞的位置是open而不是，read 或write位置处处。     \r\n\r\n   在操作有名管道的时候： 如果以某种方式打开有名管道，则系统阻塞该进程，直到有另一个进程以另\r\n   一种方式打开管道后才会继续执行（注意：非阻塞标志O_NONBLOCK）都是在open处阻塞.     \r\n\r\n  所以一个进程可以以可读可写的方式打开管道，则该进程不会阻塞\r\n\r\n\r\n信号量的相关操作P操作V操作\r\n====\r\n\r\n * 临界资源：同一时刻，只允许一个进程访问的资源      \r\n\r\n * 临界区：访问临界资源的那段代码就是临区   \r\n\r\n * 原子操作：是指要么不做要么全做   \r\n \r\n实现进程进程之间的通信和控制\r\n\r\n一：获取或是创建信号量\r\n\r\n```   \r\n  int semget(key_t key,int num_sem,int sem_flags);\r\n```  \r\n  *  第一个参数是：信号量标示符\r\n  *  第二个参数是：信号量个数\r\n  *  第三个参数是：权限\r\n\r\n  sem_flags  取值：\r\n        0666|IPC_CREAT\r\n\r\n     一般IPC_CREAT与IPC_EXCL连起来运用  作用是确保此信号量是新建的\r\n   \r\n   返回值：如果成功则返回信号量标示符（注意：是一个大于0的）\r\n     失败则返回-1\r\n\r\n二：用于改变信号量的值\r\n```\r\n  int semop(int sem_id,struct sembuf* sem_ops,size_t num_sem_ops)\r\n```\r\n   第一个参数是：信号量标示符\r\n   第二个参数是：指向下面结构体\r\n   第三个参数是:  信号量个数\r\n\r\n```c\r\n    struct sembuf {\r\n    short sem_num;\r\n  \tshort sem_op;//当P或V时         //取值不一样的  P 则              //sem_op=-1;   V 则\r\n       //sem_op=1;\r\n\tshort sem_flg;//一般取值\r\n //是 sem_flg=SEM_UNDO\r\n   };\r\n```   \r\n一般取值是 sem_flg=SEM_UNDO,含义是：   \r\n使得操作系统可以跟踪当前进程信号量的修改     \r\n\r\n 三：用于控制信号量的\r\n\r\n  int semctl(int sem_id,int sem_num,int command,...)\r\n\r\n   第一个参数是：信号量标示符\r\n   第二个参数是：信号量标号（从0开始）\r\n   第三个参数是：将要采取的动作\r\n       有删除  IPC_RMID\r\n       SETVAL 是把一个信号量设置为一个已知的值，是通过下面联合体中的val成员（一般是第一次使用时 即临界资源状态设置）\r\n\r\nunion semun\r\n{\r\nint val;\r\nstruct semid_ds *buf;\r\nunsigned short *array;\r\n};\r\n\r\n有关信号量的初始化：\r\n   \r\n\r\n注意下面是模拟 P  V操作\r\n\r\n```c   \r\n\r\n#include<sys/sem.h>\r\nint sem_init()\r\n{\r\nint semid=semget((key_t)12,1,0666|IPC_CREAT|IPC_EXCL);\r\nif(semid==-1)\r\n{\r\n   semid=semget((key_t)12,1,0666);\r\n  if(-1==semid)\r\n{\r\nperror(\"faill...\");\r\nreturn 0;\r\n}\r\n}\r\n\r\nelse\r\n{\r\nunion semun em;\r\nem.val=1;\r\nif(semctl(semid,0,SETVAL,em)==-1)\r\n{\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n\r\n}\r\n\r\nint sem_p()\r\n{\r\nstruct sembuf buf;\r\nbuf.sem_num=0;\r\nbuf.sem_op=-1;\r\nbuf.sem_flg=SEM_UNDO;\r\n\r\nif(semop(semid,buf,1)==-1)\r\n{\r\nreturn 0;\r\n}\r\nreturn 1;\r\n\r\n}\r\n\r\nint sem_V()\r\n{\r\nstruct sembuf buf;\r\nbuf.sem_num=0;\r\nbuf.sem_op=1;\r\nbuf.sem_flg=SEM_UNDO;\r\n\r\nif(semop(semid,buf,1)==-1)\r\n{\r\nreturn 0;\r\n}\r\nreturn 1;\r\n\r\n}\r\n\r\nint sem_destroy()\r\n{\r\n  if(sem_ctl(semid,0,IPC_RMID)==-1)\r\n{\r\nreturn 0;\r\n}\r\nreturn 1;\r\n\r\n}\r\n```\r\n\r\n有关共享类存的介绍\r\n====\r\n\r\n  共享类存：是允许两个不相关的进程共享一个逻辑内存\r\n```\r\n#include<sys/shm.h>\r\n```\r\n一：用于建立共享内存\r\n```\r\n  int shmget(key_t key,size_t size,int shmflg);\r\n```\r\n   第一个参数是：共享内存标示符    \r\n   第二个参数是：共享内存大小   \r\n   第三个参数是:  权限     \r\n   //IPC_CREAT    \r\n\r\n二：用于链接共享内存\r\n```\r\nvoid* shmat(int shm_id,const void *shmaddr,int shmflg);\r\n```\r\n   第一个参数是：共享内存标示符     \r\n   第二个参数是：指定内存连接到当前的地址内存位置  一般给NULL表示让系统来选择共享内存出现的位置      \r\n   第三个参数是:  权限  一般0     \r\n\r\n返回值：成功则返回共享内存的首地址     \r\n失败则返回-1   \r\n\r\n三：用于断开共享内存    \r\n```\r\nint shmdt(const void *shmaddr);\r\n```\r\n\r\n第一个参数是：共享内存首地址    \r\n\r\n返回值：       \r\n成功则返回0    \r\n失败则返回-1        \r\n\r\n三：用于删除共享内存    \r\n```\r\nint shmctl(int shm_id,int command,stuct chmid_ds *buf)\r\n```\r\n   第一个参数是：共享内存标示符    \r\n   第二个参数是：IPC_RMID   \r\n   第三个参数是:  NULL    \r\n\r\n```c\r\nint main()\r\n{\r\nint shmid=shmget((key_t)1234,256,0600|IPC_CREAT);\r\nsystem(\"ipcs\");\r\n\r\nchar*s=shmat(shmid,NULL,0);\r\nsystem(\"ipcs\");\r\n\r\nshmdt(s);\r\nsystem(\"ipcs\");\r\n\r\nshmctl(shmid,IPC_RMID，NULL);\r\nsystem(\"ipcs\");\r\n}\r\n```\r\n\r\n消息队列的实现\r\n====\r\n \r\n   消息队列提供了两个不相关进程之间的消息传递 是通过一个进程向一个存储队列中写东西  然后另一个进程就读数据    \r\n \r\n   消息队列的最大长度是由一个宏 MSGMAX决定的    \r\n\r\n　　该消息队列是独立于其进程的，即使进程都结束了　若没有进行删除操作就　仍然存在\r\n \r\n　注意：   \r\n\r\n　　　这个与共享类存相似，内核为每个消息队列都设置了一个shmid_ds 结构体  用来管理消息队列   \r\n\r\n一：获取 或是 创建消息队列   \r\n\r\n```c\r\nstruct mss\r\n{\r\n   long int type;//类型\r\n   char buff[64];\r\n};\r\n```\r\n```\r\n  #include<sys/msg.h>\r\n  int  msgget(key_t key ,int msgflg);\r\n```\r\n\r\n  第一个参数： 用来标示消息队列的关键字   \r\n  第二个参数:  标志位 如IPC_CREAT   \r\n\r\n  返回值：成功返回一个标识符（非负值）失败返回-1   \r\n     \r\n\r\n二：发送一个消息  \r\n```\r\n int msgsnd(int msgid ,void *msgp,size_t msgsize,int msgflg );\r\n```\r\n\r\n  第一个参数： 由msgget返回的消息队列标示符   \r\n  第二个参数： 指向要发送消息的缓冲区的指针    \r\n  第三个参数:  表示消息长度（不包括长整形的大小）    \r\n  第四个参数:  标志位 一般设置为0 表示当写满了就阻塞     \r\n\r\n  返回值：成功返回0 失败返回-1    \r\n  \r\n\r\n\r\n三：接收一个消息   \r\n```\r\n int msgrcv(int msgid ,void *msgp,size_t msgsize,long msgtype ,int msgflg );\r\n```\r\n\r\n  第一个参数： 由msgget返回的消息队列标示符   \r\n  第二个参数： 指向要接收消息的缓冲区的指针     \r\n  第三个参数:  表示消息长度（不包括长整形的大小）   \r\n  第四个参数:接收消息的类型 注意：当为0的时候便可以接收任何类型的   \r\n\r\n  第五个参数:  标志位 一般设置为0 表示当写满了就阻塞   \r\n\r\n  返回值：成功返回0 失败返回-1    \r\n\r\n四：删除一个消息队列   \r\n```\r\n int msgctl(int msgid,int cmd,struct msgid_ds *buf)\r\n```\r\n  第一个参数： 由msgget返回的消息队列标示符     \r\n\r\n  第二个参数： 采取的动作 IPC_RMID(删除)IPC_STAT(将内核的拷到buf)IPC_SET(将buf的拷到内核  权限足够)   \r\n  \r\n  第三个参数:缓冲区  一般为0   \r\n\r\n 注意：消息队列的长度是65536   \r\n   \r\n消息队列的结构体 \r\n\r\n```\r\n struct msgqid_ds\r\n {\r\n    msgqnum_t msg_qnum;\r\n    msglen_t msg_qbytes;//队列的大小\r\n    pid_t msg_lspid;\r\n    \r\n };\r\n```\r\n\r\n总结对比：\r\n===\r\n\r\n有关信号，管道，信号量，共享内存，消息队列的总结    \r\n\r\n *  1：首先信号与信号量的区别：信号是用来进程间的通信（kill发送信号 signal接收信号）   \r\n而信号量是用与控制临界资源的访问     \r\n\r\n * 2：有关管道与共享内存以及消息队列的区别与联系    \r\n\r\n   首先管道（是一种半双工通信）分为有名与无名管道，无名管道只可以用于有亲缘关系的进程通信（通常只有\r\n一个读进程以及一个写进程）但是有名管道却可以有多个（可以用于两个无关的进程之间的通信），会产生一个fifo文件，\r\n管道的实现原理：通过两个指针来控制一个缓冲区（是一个大小固定的4k）（还用到了信号和加锁机制）    \r\n\r\n * 3：消息队列与有名管道的却别：    \r\n\r\n * 4：共享内存方式是进程之间通信的最快方式，而消息队列以及管道都需要在内核和用户空间进行四次的数据拷贝   \r\n\r\n \r\n 终结：   \r\n 共享内存（是通过mmap（）映射普通文件实现的）以及消息队列（其共享的区域的生存期不与通信进程结束相关）除非\r\n 显示的删除，否则是同内核持续的，而无名管道却不是这样的，但是有名管道却是持久的     \r\n\r\n从其效率看：共享内存最快，管道是所有的unix都支持的而消息队列 有些unix还不支持    \r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"linux process commuinte pipe signal sem shm","note":"Don't delete this file! It's used internally to help with page regeneration."}